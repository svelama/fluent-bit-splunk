---
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-lua-scripts
  namespace: logging
data:
  retag_logs.lua: |
    -- Re-tag logs based on pod label and container name
    -- If pod has label "consumer-splunk-index" AND container name is "app" → tag as "consumer-logs"
    -- All other logs → tag as "tdp-infra"

    function retag_by_label_and_container(tag, timestamp, record)
        local kubernetes = record["kubernetes"]
        local new_tag = "tdp-infra"  -- Default tag

        if kubernetes then
            local labels = kubernetes["labels"]
            local container_name = kubernetes["container_name"]

            -- Check if pod has the "consumer-splunk-index" label AND container name is "app"
            if labels and labels["consumer-splunk-index"] and container_name == "app" then
                -- Extract the index value from the label and add it to the record
                record["splunk_index"] = labels["consumer-splunk-index"]
                record["_log_type"] = "consumer"
                new_tag = "consumer-logs"
            else
                -- All other logs are tagged as tdp-infra
                record["_log_type"] = "infrastructure"
                new_tag = "tdp-infra"
            end
        end

        -- Store the new tag in the record for reference
        record["_original_tag"] = tag
        record["_new_tag"] = new_tag

        -- Return code 1 (keep record) - we'll use rewrite_tag filter for actual re-tagging
        return 1, timestamp, record
    end

  enrich_splunk.lua: |
    -- Enrich logs with Splunk token from Kubernetes secrets
    -- Note: splunk-index is already added by retag_logs.lua from pod label

    local secret_cache = {}
    local cache_ttl = 1800  -- 30 minute cache
    local default_secret_name = "splunk-token"

    function execute_command(cmd)
        local handle = io.popen(cmd)
        if not handle then
            return nil
        end
        local result = handle:read("*a")
        handle:close()
        return result
    end

    function get_k8s_secret(namespace, secret_name)
        local cache_key = namespace .. "/" .. secret_name
        local cached = secret_cache[cache_key]

        -- Check cache
        if cached and (os.time() - cached.timestamp) < cache_ttl then
            return cached.data
        end

        -- Read service account token
        local token_file = io.open("/var/run/secrets/kubernetes.io/serviceaccount/token", "r")
        if not token_file then
            return nil, "Failed to read token"
        end
        local token = token_file:read("*a")
        token_file:close()

        -- Fetch secret from Kubernetes API
        local url = string.format("https://kubernetes.default.svc/api/v1/namespaces/%s/secrets/%s",
                                 namespace, secret_name)

        local curl_cmd = string.format(
            'curl -s --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H "Authorization: Bearer %s" %s 2>/dev/null',
            token, url
        )

        local response = execute_command(curl_cmd)

        if not response or response == "" then
            return nil, "Empty response"
        end

        -- Parse base64-encoded secret data (only token now)
        local splunk_token_b64 = response:match('"splunk%-token"%s*:%s*"([^"]+)"')

        if not splunk_token_b64 then
            return nil, "Missing splunk-token in secret"
        end

        -- Decode base64 value
        local splunk_token = execute_command(string.format('echo "%s" | base64 -d 2>/dev/null', splunk_token_b64))

        -- Clean up decoded value
        if splunk_token then
            splunk_token = splunk_token:gsub("\n", ""):gsub("\r", "")
        end

        if not splunk_token or splunk_token == "" then
            return nil, "Failed to decode token"
        end

        local secret_data = {
            token = splunk_token
        }

        -- Cache the result
        secret_cache[cache_key] = {
            data = secret_data,
            timestamp = os.time()
        }

        return secret_data
    end

    function enrich_with_splunk_config(tag, timestamp, record)
        local kubernetes = record["kubernetes"]

        if not kubernetes then
            return -1, timestamp, record
        end

        local namespace = kubernetes["namespace_name"]
        local labels = kubernetes["labels"]

        if not namespace then
            return -1, timestamp, record
        end

        -- Determine secret name (from pod label or use default)
        local secret_name = default_secret_name
        if labels and labels["splunk-token-secret"] then
            secret_name = labels["splunk-token-secret"]
        end

        -- Fetch secret from Kubernetes API
        local secret_data, err = get_k8s_secret(namespace, secret_name)

        if not secret_data then
            -- Log error in record for debugging
            record["_secret_fetch_error"] = err or "unknown"
            record["_secret_name"] = secret_name
            record["_namespace"] = namespace
            -- Keep record but mark it for troubleshooting
            return 1, timestamp, record
        end

        -- Enrich record with Splunk token
        -- Note: splunk_index is already set by retag_logs.lua from pod label
        record["splunk_token"] = secret_data.token
        record["_enriched"] = "true"

        return 1, timestamp, record
    end
